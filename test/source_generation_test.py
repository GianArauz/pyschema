# Copyright (c) 2015 Spotify AB
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

import sys
import subprocess
from unittest import TestCase
from pyschema import Record, Text, Integer, no_auto_store, Enum, SubRecord
from pyschema.source_generation import to_python_source, classes_source, has_directed_link
from . import source_generation_helpers


@no_auto_store()
class FooRecord(Record):
    _namespace = "my.foo.bar"
    field_1 = Text()
    a = 5
    bar = Integer()


class TestSourceConversion(TestCase):
    def foo_record_test(self):
        src = classes_source([FooRecord], indent=" " * 4)
        correct = (
            "class FooRecord(pyschema.Record):\n"
            "    # WARNING: This class was generated by pyschema.to_python_source\n"
            "    # there is a risk that any modification made to this class will be overwritten\n"
            "    _namespace = \'my.foo.bar\'\n"
            "    field_1 = Text(nullable=True, default=None)\n"
            "    bar = Integer(nullable=True, default=None)\n"
        )
        self.assertEqual(
            src,
            correct,
            msg="Incorrect definition:\n\"\"\"\n{0}\"\"\"\nShould have been:\n\"\"\"\n{1}\"\"\"".format(src, correct)
        )


class NonZeroExit(Exception):
    # custom error since check_output doesn't exist in python 2.6
    def __init__(self, code, output):
        self.message = "Python interpreter exited with status {0}. Error output:\n{1}".format(code, output)

    def __str__(self):
        return self.message


def call_python(source):
    p = subprocess.Popen([sys.executable, "-c", source], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    p.wait()

    if p.returncode:
        raise NonZeroExit(p.returncode, p.stdout.read())


class AutoTest(object):
    schema_classes = []

    def test_parsable(self):
        src = to_python_source(self.schema_classes)
        assertion_footer = "\n".join(
            "assert {0}".format(schema._schema_name)
            for schema in self.schema_classes
        )
        try:
            call_python(src + '\n' + assertion_footer)
        except NonZeroExit as e:
            self.fail("Problem when parsing:\n\n{0}\n\n{1}".format(src, e.message))


class TestFooRecord(AutoTest, TestCase):
    schema_classes = [FooRecord]


@no_auto_store()
class EnumRecord(Record):
    e = Enum(["HELLO", "GOODBYE"])


class TestEnumRecord(AutoTest, TestCase):
    schema_classes = [EnumRecord]


class TestDirectedLink(TestCase):
    def test_a_to_b(self):
        self.assertTrue(
           has_directed_link(source_generation_helpers.A, source_generation_helpers.B)
        )

    def test_b_to_a(self):
        self.assertFalse(
           has_directed_link(source_generation_helpers.B, source_generation_helpers.A)
        )


class DependentRecords(AutoTest, TestCase):
    schema_classes = [source_generation_helpers.A, source_generation_helpers.B]


class DependentRecordsOther(AutoTest, TestCase):
    schema_classes = [source_generation_helpers.B, source_generation_helpers.A]


@no_auto_store()
class Child(Record):
    a = Integer()


@no_auto_store()
class Parent(Record):
    child = SubRecord(Child)


class TestSubRecord(TestCase):
    correct = """class Child(pyschema.Record):
    # WARNING: This class was generated by pyschema.to_python_source
    # there is a risk that any modification made to this class will be overwritten
    a = Integer(nullable=True, default=None)


class Parent(pyschema.Record):
    # WARNING: This class was generated by pyschema.to_python_source
    # there is a risk that any modification made to this class will be overwritten
    child = SubRecord(schema=Child, nullable=True, default=None)
"""

    def test_implicit_inclusion(self):
        src = classes_source([Parent])

        self.assertEquals(
            src,
            self.correct,
            msg="Incorrect definition:\n\"\"\"\n{0}\"\"\"\nShould have been:\n\"\"\"\n{1}\"\"\"".format(src, self.correct)
        )
